"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[564],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=l,f=d["".concat(o,".").concat(m)]||d[m]||c[m]||r;return n?a.createElement(f,i(i({ref:t},u),{},{components:n})):a.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:l,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5787:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),l=(n(7294),n(3905));const r={sidebar_position:2},i="Object Types",s={unversionedId:"object-types",id:"object-types",title:"Object Types",description:"GraphQL object types are defined using the annotation @gql.type on a ReScript record:",source:"@site/docs/object-types.md",sourceDirName:".",slug:"/object-types",permalink:"/resgraph/docs/object-types",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/object-types.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/resgraph/docs/getting-started"},next:{title:"Enums",permalink:"/resgraph/docs/enums"}},o={},p=[{value:"Fields",id:"fields",level:2},{value:"Adding fields to types via functions",id:"adding-fields-to-types-via-functions",level:3},{value:"Adding arguments to your fields",id:"adding-arguments-to-your-fields",level:3},{value:"Handling <code>null</code> in arguments",id:"handling-null-in-arguments",level:4},{value:"Deprecating fields",id:"deprecating-fields",level:3},{value:"Using app context in field functions",id:"using-app-context-in-field-functions",level:3},{value:"Accessing <code>GraphQLResolveInfo</code> for each resolver",id:"accessing-graphqlresolveinfo-for-each-resolver",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,l.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"object-types"},"Object Types"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://graphql.org/learn/schema/#object-types-and-fields"},"GraphQL object types")," are defined using the annotation ",(0,l.kt)("inlineCode",{parentName:"p"},"@gql.type")," on a ReScript record:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},"/** A user in the system. */\n@gql.type\ntype user = {\n  age: int,\n  lastName: string,\n  /** The first name of the user. */\n  @gql.field\n  firstName: string,\n\n}\n\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA user in the system.\n"""\ntype User {\n  """\n  The first name of the user.\n  """\n  firstName: String!\n}\n')),(0,l.kt)("p",null,"Notice a few things here:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Comments on types and fields end up in the GraphQL schema."),(0,l.kt)("li",{parentName:"ul"},"You can expose fields directly from the type by annotating a record field with ",(0,l.kt)("inlineCode",{parentName:"li"},"@gql.field"),". This is useful when you don't need to do any transformation of the underlying data before you return it to GraphQL.")),(0,l.kt)("h2",{id:"fields"},"Fields"),(0,l.kt)("p",null,"Building on point 2 above, there are two ways to add fields to a type. One is annotating fields with ",(0,l.kt)("inlineCode",{parentName:"p"},"@gql.field"),". This will expose them as-is directly in the schema, meaning the raw value will be returned."),(0,l.kt)("p",null,"The second way is to define a field on a type via a function. What's commonly called a ",(0,l.kt)("em",{parentName:"p"},"resolver")," in GraphQL."),(0,l.kt)("h3",{id:"adding-fields-to-types-via-functions"},"Adding fields to types via functions"),(0,l.kt)("p",null,"You can add a field to a GraphQL type this way:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},"/** The full name of the user. */\n@gql.field\nlet fullName = (user: user) => {\n  Some(`${user.firstName} ${user.lastName}`)\n}\n")),(0,l.kt)("p",null,"This will expose ",(0,l.kt)("inlineCode",{parentName:"p"},"fullName")," as a field on ",(0,l.kt)("inlineCode",{parentName:"p"},"User"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA user in the system.\n"""\ntype User {\n  """\n  The first name of the user.\n  """\n  firstName: String!\n\n  """\n  The full name of the user.\n  """\n  fullName: String\n}\n')),(0,l.kt)("p",null,"Notice a few things:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"The function takes a ",(0,l.kt)("inlineCode",{parentName:"li"},"user")," as the first, unlabelled argument. This is how ResGraph figures out what type this field should be attached to."),(0,l.kt)("li",{parentName:"ol"},"Comments work just like you'd expect, and they end up in the schema."),(0,l.kt)("li",{parentName:"ol"},"We don't annotate the return type of the function, but we could if we'd like to."),(0,l.kt)("li",{parentName:"ol"},"This is a sync function, but it could just as well be an ",(0,l.kt)("inlineCode",{parentName:"li"},"async")," function. ResGraph handles both.")),(0,l.kt)("p",null,"This is likely going to be the main way you add fields to your object types. Let's dive in to how to do a few more things:"),(0,l.kt)("h3",{id:"adding-arguments-to-your-fields"},"Adding arguments to your fields"),(0,l.kt)("p",null,"Using arguments for your field is as easy as adding a labelled argument to your function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},'/** The full name of the user. */\n@gql.field\nlet fullName = (user: user, ~includeInitials=false) => {\n  let initials = if includeInitials {\n    ` (${getFirstCharUppercased(user.firstName)} ${getFirstCharUppercased(user.lastName)})`\n  } else {\n    ""\n  }\n\n  Some(`${user.firstName} ${user.lastName}${initials}`)\n}\n')),(0,l.kt)("p",null,"This will add the argument ",(0,l.kt)("inlineCode",{parentName:"p"},"includeInitials")," to your field."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA user in the system.\n"""\ntype User {\n  """\n  The first name of the user.\n  """\n  firstName: String!\n\n  """\n  The full name of the user.\n  """\n  fullName(includeInitials: Boolean): String\n}\n')),(0,l.kt)("p",null,"Arguments can also be ",(0,l.kt)("a",{parentName:"p",href:"input-objects"},"input objects"),", ",(0,l.kt)("a",{parentName:"p",href:"custom-scalars"},"custom scalars")," and so on."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note: Anything exposed to GraphQL, like fields, arguments and so on, must all be ",(0,l.kt)("a",{parentName:"p",href:"valid-graphql-types"},"valid GraphQL types"),". ResGraph will complain (and tell you how to fix it) if you try and use anything not valid.")),(0,l.kt)("h4",{id:"handling-null-in-arguments"},"Handling ",(0,l.kt)("inlineCode",{parentName:"h4"},"null")," in arguments"),(0,l.kt)("p",null,"By default, all optional arguments are collapsed into a ReScript ",(0,l.kt)("inlineCode",{parentName:"p"},"option"),". But, arguments can be explicitly set to ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," from the client in GraphQL. So, by default, whether the argument value was indeed ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," or just not set, is lost. This is OK for the vast majority of cases, but there ",(0,l.kt)("em",{parentName:"p"},"are")," cases when you do want to know whether some argument was explicitly ",(0,l.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,l.kt)("p",null,"To solve that, just ensure your argument is of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t")," (TODO: Core ",(0,l.kt)("inlineCode",{parentName:"p"},"Nullable.t")," instead). For any argument that's annotated as (or inferred to be) ",(0,l.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),", ResGraph will preserve ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," values."),(0,l.kt)("p",null,"Let's look at an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},'@gql.field\nlet wasNull = async (_: query, ~blogPostId: Js.Nullable.t<ResGraph.id>) => {\n  switch blogPostId {\n  | Null => "Value was null"\n  | Undefined => "Value was undefined"\n  | Value(blogPostId) => "Id was: " ++ blogPostId->ResGraph.idToString\n  }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  wasNull(blogPostId: ID): String!\n}\n")),(0,l.kt)("h3",{id:"deprecating-fields"},"Deprecating fields"),(0,l.kt)("p",null,"Deprecate fields via the ",(0,l.kt)("inlineCode",{parentName:"p"},"@deprecated")," attribute:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.type\ntype user = {\n  age: int,\n  lastName: string,\n  @gql.field @deprecated(\"This is going away, use 'fullName' instead.\")\n  firstName: string,\n\n}\n\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},"type User {\n  firstName: String!\n    @deprecated(reason: \"This is going away, use 'fullName' instead.\")\n}\n")),(0,l.kt)("h3",{id:"using-app-context-in-field-functions"},"Using app context in field functions"),(0,l.kt)("p",null,"To use the app context in your field functions, add a labelled argument annotated with ",(0,l.kt)("inlineCode",{parentName:"p"},"ResGraphContext.context")," (the context you've created and defined) and ResGraph will inject your app context into that argument for your field:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},'/** The full name of the user. */\n@gql.field\nlet fullName = (user: user, ~includeInitials=false, ~ctx: ResGraphContext.context) => {\n  let initials = if includeInitials {\n    // Imagine we\'ve added `utils.nameToInitials` to our context\n    ctx.utils.nameToInitials(user.firstName, user.lastName)\n  } else {\n    ""\n  }\n\n  Some(`${user.firstName} ${user.lastName}${initials}`)\n}\n')),(0,l.kt)("p",null,"This is going to be where you use data loaders and other per-request contextual helpers from."),(0,l.kt)("h2",{id:"accessing-graphqlresolveinfo-for-each-resolver"},"Accessing ",(0,l.kt)("inlineCode",{parentName:"h2"},"GraphQLResolveInfo")," for each resolver"),(0,l.kt)("p",null,"Similarly to accessing the context, you can get access to the ",(0,l.kt)("inlineCode",{parentName:"p"},"resolveInfo")," argument for each resolver (typed as ",(0,l.kt)("inlineCode",{parentName:"p"},"GraphQLResolveInfo"),") by adding a labelled argument annotated with ",(0,l.kt)("inlineCode",{parentName:"p"},"ResGraph.resolveInfo"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rescript"},'/** The full name of the user. */\n@gql.field\nlet fullName = (user: user, ~info: ResGraph.resolveInfo) => {\n  Console.log(info)\n\n  Some("Test User")\n}\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note: The ",(0,l.kt)("inlineCode",{parentName:"p"},"resolveInfo")," type is currently not complete. It'll be extended in the future to give you access to all the information in ",(0,l.kt)("inlineCode",{parentName:"p"},"info")," directly, but for now you can write your own bindings for the things in ",(0,l.kt)("inlineCode",{parentName:"p"},"GraphQLResolveInfo")," that you need, and then just cast ",(0,l.kt)("inlineCode",{parentName:"p"},"resolveInfo")," to that.")))}c.isMDXComponent=!0}}]);