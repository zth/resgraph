"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[690],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,d=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(n),m=i,u=c["".concat(d,".").concat(m)]||c[m]||h[m]||o;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8361:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const o={},r="The Node Interface",l={unversionedId:"node-interface",id:"node-interface",title:"The Node Interface",description:"You're encouraged to read up on the Node interface before reading this text. Here's a general article on the Node interface, and here's the relevant best practices section from the GraphQL documentation.",source:"@site/docs/node-interface.md",sourceDirName:".",slug:"/node-interface",permalink:"/resgraph/docs/node-interface",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/node-interface.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Developer Experience",permalink:"/resgraph/docs/developer-experience"},next:{title:"Pagination",permalink:"/resgraph/docs/pagination"}},d={},s=[{value:"Node interface crash course",id:"node-interface-crash-course",level:3},{value:"The Node interface in ResGraph",id:"the-node-interface-in-resgraph",level:2},{value:"1. Defining the Node interface",id:"1-defining-the-node-interface",level:3},{value:"2. Implementing the globally unique <code>id</code> field for each type",id:"2-implementing-the-globally-unique-id-field-for-each-type",level:3},{value:"Expose a <code>node</code> field on <code>Query</code>",id:"expose-a-node-field-on-query",level:3},{value:"Advanced patterns",id:"advanced-patterns",level:2},{value:"Obfuscating the <code>id</code>",id:"obfuscating-the-id",level:3},{value:"Base64 encoding <code>id</code>",id:"base64-encoding-id",level:3}],p={toc:s},c="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"the-node-interface"},"The Node Interface"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"You're encouraged to read up on the Node interface before reading this text. Here's a ",(0,i.kt)("a",{parentName:"p",href:"https://dev.to/zth/the-magic-of-the-node-interface-4le1"},"general article on the Node interface"),", and here's the relevant ",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/global-object-identification/"},"best practices section from the GraphQL documentation"),".")),(0,i.kt)("p",null,"If you want to unlock the true power of GraphQL clients like Relay, you're strongly encouraged to implement what's called the Node interface."),(0,i.kt)("h3",{id:"node-interface-crash-course"},"Node interface crash course"),(0,i.kt)("p",null,"The Node interface is essentially a convention that lets each node in the graph:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Have an ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," that's unique in your ",(0,i.kt)("em",{parentName:"li"},"entire")," graph, not just among the type the node is of."),(0,i.kt)("li",{parentName:"ol"},"Be possible to refetch each node by itself only via its ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),". Meaning it needs to be possible to destruct ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," into something that reveals both the ",(0,i.kt)("em",{parentName:"li"},"actual")," ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),", and what type it's for, so we know what type to fetch.")),(0,i.kt)("p",null,"Together, these two points enable clients like Relay to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Do normalized caching effortlessly, which brings all sorts of goodies like data consistency, automatic cache updates and so on."),(0,i.kt)("li",{parentName:"ol"},"Automatically build queries for pagination and refetching, so you don't have to write those queries yourself.")),(0,i.kt)("p",null,"In a nutshell, the Node interface looks and works something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"# The schema\n\n# Defines the Node interface\ninterface Node {\n  id: ID!\n}\n\n# Each type implementing Node should have a globally unique ID\ntype User implements Node {\n  id: ID!\n  name: String!\n}\n\n# `Query` should have a top level field called `node` that lets you refetch any node in the graph by its id\ntype Query {\n  node(id: ID!): Node\n}\n")),(0,i.kt)("p",null,"Now, imagine we've got an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," for a ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," from somewhere in our graph. Without having to care about ",(0,i.kt)("em",{parentName:"p"},"where")," that ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," came from, we can fetch data from that exact user via the Node interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"query NodeTestQuery($userId: ID!) {\n  node(id: $userId) {\n    ... on User {\n      name\n    }\n  }\n}\n")),(0,i.kt)("p",null,"This would return data from ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," if the value we pass to ",(0,i.kt)("inlineCode",{parentName:"p"},"userId")," is indeed an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," coming from a ",(0,i.kt)("inlineCode",{parentName:"p"},"User"),"."),(0,i.kt)("h2",{id:"the-node-interface-in-resgraph"},"The Node interface in ResGraph"),(0,i.kt)("p",null,"Now, all of the above sounds great. But it's up to you to implement all of that in practice. From our long experience of building GraphQL servers we know that this can feel and be much trickier than it needs to be. So, let us walk you through how easy implementing the Node interface is in ResGraph."),(0,i.kt)("p",null,"In a nutshell, what we need to do is the following:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Define our ",(0,i.kt)("inlineCode",{parentName:"li"},"Node")," interface type."),(0,i.kt)("li",{parentName:"ol"},"Expose a field called ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," from that interface. That ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," needs to be an ",(0,i.kt)("inlineCode",{parentName:"li"},"ID")," in GraphQL, and needs to resolve as a globally unique ID for each type that implements it."),(0,i.kt)("li",{parentName:"ol"},"Expose a ",(0,i.kt)("inlineCode",{parentName:"li"},"node")," field on ",(0,i.kt)("inlineCode",{parentName:"li"},"Query")," that takes an ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," and can resolve each of the types that implement the ",(0,i.kt)("inlineCode",{parentName:"li"},"Node")," interface.")),(0,i.kt)("p",null,"Let's get started!"),(0,i.kt)("h3",{id:"1-defining-the-node-interface"},"1. Defining the Node interface"),(0,i.kt)("p",null,"Start by defining the Node interface. The Node interface is a convention, so it's important that it's named ",(0,i.kt)("inlineCode",{parentName:"p"},"node"),", even though there's nothing ",(0,i.kt)("em",{parentName:"p"},"actually")," magical about that name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rescript"},"// NodeInterface.res\n@gql.interface\ntype node = {\n  id: string\n}\n")),(0,i.kt)("p",null,"Notice we don't expose ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," as a GraphQL field directly, nor do we type it as ",(0,i.kt)("inlineCode",{parentName:"p"},"ResGraph.id"),". More on why in the next step."),(0,i.kt)("h3",{id:"2-implementing-the-globally-unique-id-field-for-each-type"},"2. Implementing the globally unique ",(0,i.kt)("inlineCode",{parentName:"h3"},"id")," field for each type"),(0,i.kt)("p",null,"Now we need to make sure that each and every type that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," has an ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field that returns a ",(0,i.kt)("em",{parentName:"p"},"globally unique id"),". We'll do this step by step. Let's start by defining a field ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," for the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rescript"},"// NodeInterfaceResolvers.res\n@gql.field\nlet id = (node: NodeInterface.node) => {\n  node.id->ResGraph.id\n}\n")),(0,i.kt)("p",null,"This adds an ",(0,i.kt)("inlineCode",{parentName:"p"},"id: ID!")," field to all types that implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),". Great! But this is just returning the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," coming from the type itself, so it's not going to be globally unique by default."),(0,i.kt)("p",null,'One "naive" idea would be to have a separate ',(0,i.kt)("inlineCode",{parentName:"p"},"id")," field function for each type to produce the globally unique ID:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.field\nlet id = (user: user) => {\n  `User:${user.id}`->ResGraph.id\n}\n")),(0,i.kt)("p",null,"But that will get old fast as we add new types and need to add new field functions just for the ID every time."),(0,i.kt)("p",null,"Instead, we can leverage ",(0,i.kt)("a",{parentName:"p",href:"interfaces#accessing-what-type-the-interface-field-function-is-currently-working-on"},"accessing what type the interface field function is currently working on"),". That, together with helpers that ResGraph generates for us, means we can build our generic node ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field in a way that'll work for all types that implement it automatically, without having to roll separate field functions for each type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rescript"},"// NodeInterfaceResolvers.res\n@gql.field\nlet id = (node: NodeInterface.node, ~typename: ResGraphSchemaAssets.node_implementedBy) => {\n  `${typename->ResGraphSchemaAssets.node_typenameToString}:${node.id}`->ResGraph.id\n}\n")),(0,i.kt)("p",null,"There! Now every ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," field of every type that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," will be globally unique, and in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"<type>:<id>"),". So, for a user with the ID ",(0,i.kt)("inlineCode",{parentName:"p"},"123"),", the globally unique ID will automatically be generated as ",(0,i.kt)("inlineCode",{parentName:"p"},"User:123"),"."),(0,i.kt)("h3",{id:"expose-a-node-field-on-query"},"Expose a ",(0,i.kt)("inlineCode",{parentName:"h3"},"node")," field on ",(0,i.kt)("inlineCode",{parentName:"h3"},"Query")),(0,i.kt)("p",null,"The final thing we need to do before we have a fully working Node interface setup is to implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"node")," field on ",(0,i.kt)("inlineCode",{parentName:"p"},"Query"),", that takes any ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," from a node and resolves its type."),(0,i.kt)("p",null,"Fortunately, ResGraph generates helpers for this task as well. Let's look at how an implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"node")," field can look:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rescript"},'/** Fetches an object given its ID.*/\n@gql.field\nlet node = async (_: Query.query, ~id, ~ctx: ResGraphContext.context): option<\n  ResGraphSchemaAssets.node_resolver,\n> => {\n  switch id->ResGraph.idToString->String.split(":") {\n  | [typenameAsString, id] =>\n    switch typenameAsString->ResGraphSchemaAssets.decodeImplementedByInterface_node {\n    | None => None\n    | Some(User) =>\n      switch await ctx.dataLoaders.userById.load(~userId=id) {\n      | Ok(user) => Some(User(user))\n      | Error(_) => None\n      }\n    | Some(Group) =>\n      switch await ctx.dataLoaders.groupById.load(~userId=id) {\n      | Ok(group) => Some(Group(group))\n      | Error(_) => None\n      }\n    }\n  | _ => None\n  }\n}\n')),(0,i.kt)("p",null,"Lots of things to distill here."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We annotate the return type of our field function as ",(0,i.kt)("inlineCode",{parentName:"li"},"ResGraphSchemaAssets.node_resolver"),". This type is autogenerated, and is what ensures that you can return only types that implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Node"),". It also informs ResGraph that it's indeed the ",(0,i.kt)("em",{parentName:"li"},"interface")," ",(0,i.kt)("inlineCode",{parentName:"li"},"Node")," you're returning from this field."),(0,i.kt)("li",{parentName:"ol"},"Remember that we formatted our IDs like ",(0,i.kt)("inlineCode",{parentName:"li"},"<type>:<id>"),". Because of that, we start by decoding the raw id passed to ",(0,i.kt)("inlineCode",{parentName:"li"},"node")," by splitting the ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," on ",(0,i.kt)("inlineCode",{parentName:"li"},":")," to extract our type and real id."),(0,i.kt)("li",{parentName:"ol"},"We then use ",(0,i.kt)("inlineCode",{parentName:"li"},"ResGraphSchemaAssets.decodeImplementedByInterface_node")," to decode that string into a ",(0,i.kt)("inlineCode",{parentName:"li"},"ResGraphSchemaAssets.node_implementedBy")," type. These are both autogenerated by ResGraph, and will stay up to date with any types that start (or stop) implementing the Node interface. ",(0,i.kt)("inlineCode",{parentName:"li"},"node_implementedBy")," is a variant listing all typenames that implement ",(0,i.kt)("inlineCode",{parentName:"li"},"Node"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"decodeImplementedByInterface_node")," is a function that decodes a string into a ",(0,i.kt)("inlineCode",{parentName:"li"},"node_implementedBy"),"."),(0,i.kt)("li",{parentName:"ol"},"Now we have a type, and an id. We can move on to resolving the correct nodes.")),(0,i.kt)("p",null,"There! Now we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"node")," field that can resolve any node implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"Node")," interface by itself."),(0,i.kt)("h2",{id:"advanced-patterns"},"Advanced patterns"),(0,i.kt)("p",null,"So far we've done an as simple implementation of our IDs as possible. However, there are several more things you might want to consider. In this section we'll discuss those considerations a bit."),(0,i.kt)("h3",{id:"obfuscating-the-id"},"Obfuscating the ",(0,i.kt)("inlineCode",{parentName:"h3"},"id")),(0,i.kt)("p",null,'One thing you can consider is to "obfuscate" the ',(0,i.kt)("inlineCode",{parentName:"p"},"id")," so it doesn't read ",(0,i.kt)("inlineCode",{parentName:"p"},"<type>:<id>")," if you inspect it at runtime. Doing this can be for several reasons:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"id")," should be considered opaque, as in the client should not be tempted to rely on its implementation, because the server owns it and should be allowed to change it at any time. Obfuscating the ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),' so it\'s not directly human readable is a simple way to communicate to the client that "this is intended to be opaque to you".'),(0,i.kt)("li",{parentName:"ol"},"You might want to stick the ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," into links and URL:s, meaning they'll need to be URL safe and generally look like an id you're not tempted to tamper with in the URL.")),(0,i.kt)("p",null,"The most common way in GraphQL to handle this is to encode the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," as (URL safe) base64. Let's look at how you can do that easily with ResGraph."),(0,i.kt)("h3",{id:"base64-encoding-id"},"Base64 encoding ",(0,i.kt)("inlineCode",{parentName:"h3"},"id")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TODO: Finish as we've merged the connection branch")))}h.isMDXComponent=!0}}]);