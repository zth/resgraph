"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[637],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(a),d=r,h=c["".concat(o,".").concat(d)]||c[d]||m[d]||l;return a?n.createElement(h,s(s({ref:t},u),{},{components:a})):n.createElement(h,s({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,s=new Array(l);s[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[c]="string"==typeof e?e:r,s[1]=i;for(var p=2;p<l;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},1060:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const l={sidebar_position:6},s="Custom Scalars",i={unversionedId:"custom-scalars",id:"custom-scalars",title:"Custom Scalars",description:"A custom scalar is a scalar type in your schema where the underlying value is (somewhat) opaque to the client.",source:"@site/docs/custom-scalars.md",sourceDirName:".",slug:"/custom-scalars",permalink:"/resgraph/docs/custom-scalars",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/custom-scalars.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Interfaces",permalink:"/resgraph/docs/interfaces"},next:{title:"Input Objects",permalink:"/resgraph/docs/input-objects"}},o={},p=[{value:"Simple custom scalars",id:"simple-custom-scalars",level:2},{value:"Caveats",id:"caveats",level:3},{value:"Opaque types and custom scalars",id:"opaque-types-and-custom-scalars",level:2},{value:"Custom scalars that need custom parsing and serializing",id:"custom-scalars-that-need-custom-parsing-and-serializing",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"custom-scalars"},"Custom Scalars"),(0,r.kt)("p",null,"A custom scalar is a scalar type in your schema where the underlying value is (somewhat) opaque to the client."),(0,r.kt)("p",null,"Custom scalars are defined using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@gql.scalar")," attribute in ResGraph. Here follows a description of how you can leverage simple and more advanced type setups for custom scalars."),(0,r.kt)("h2",{id:"simple-custom-scalars"},"Simple custom scalars"),(0,r.kt)("p",null,"The simplest way to define a custom scalar is to use a type alias:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"/** A timestamp. */\n@gql.scalar\ntype timestamp = float\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA timestamp.\n"""\nscalar Timestamp\n')),(0,r.kt)("p",null,"A simple custom scalar has the following restrictions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Must be a type alias."),(0,r.kt)("li",{parentName:"ul"},"The type alias must be to a type that's a ",(0,r.kt)("a",{parentName:"li",href:"#valid-graphql-types"},"valid GraphQL type"),".")),(0,r.kt)("h3",{id:"caveats"},"Caveats"),(0,r.kt)("p",null,"Because this is a type alias, you'll need to use explicit type annotations to tell ResGraph that you're looking to use your new scalar type rather than the underlying primitive."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.scalar\ntype timestamp = float\n\n@gql.field\nlet currentTime = (_: query) => {\n  Date.now()\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"scalar Timestamp\n\ntype Query {\n  currentTime: Float!\n}\n")),(0,r.kt)("p",null,"Notice that there's no way for ResGraph to know that you meant to use your ",(0,r.kt)("inlineCode",{parentName:"p"},"Timestamp")," scalar, and not ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),". You solve this either by annotating the function return type with ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp"),", or by assinging the value you want to return to a value that's annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp"),", and then return that value. Both examplified here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.scalar\ntype timestamp = float\n\n@gql.field\nlet currentTime = (_: query): timestamp => {\n  // Either annotate the return type, like above,\n  // or annotate an intermediate value, like below:\n  let time: timestamp = Date.now()\n  time\n}\n")),(0,r.kt)("p",null,"Now ResGraph understands that you're returning a custom scalar:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"scalar Timestamp\n\ntype Query {\n  currentTime: Timestamp!\n}\n")),(0,r.kt)("h2",{id:"opaque-types-and-custom-scalars"},"Opaque types and custom scalars"),(0,r.kt)("p",null,"The ease of leveraging opaque types is one of the main strengths of ReScript. ResGraph makes it easy to leverage them when building your GraphQL server as well."),(0,r.kt)("p",null,"To define a custom scalar backed by an abstract type, do this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"module Timestamp: {\n  /** A timestamp. */\n  @gql.scalar\n  type t\n\n  let make: unit => t\n} = {\n  type t = float\n  let make = () => Date.now()\n}\n\n@gql.field\nlet currentTime = (_: query) => {\n  Timestamp.make()\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA timestamp.\n"""\nscalar Timestamp\n\ntype Query {\n  currentTime: Timestamp!\n}\n')),(0,r.kt)("p",null,"Notice a few things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The opaque type must be named exactly ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),", and annotated with ",(0,r.kt)("inlineCode",{parentName:"li"},"@gql.scalar"),"."),(0,r.kt)("li",{parentName:"ul"},"The name of the custom scalar will be derived from the ",(0,r.kt)("em",{parentName:"li"},"module name")," when the type is ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),".")),(0,r.kt)("p",null,"Notice also that while the type ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," is opaque in your server, you're not forced to show how to serialize and parse your custom scalar if its underlying type is a valid GraphQL type. This is because ResGraph will look at your implementation."),(0,r.kt)("p",null,"However, there are cases when you either must define a way to parse and serialize a custom scalar, because its underlying represenation isn't a valid GraphQL type. Or when you want to control how the custom scalar is parsed and serialized for other reasons."),(0,r.kt)("p",null,"In those cases, you can define a custom scalar with a custom parser and serializer:"),(0,r.kt)("h2",{id:"custom-scalars-that-need-custom-parsing-and-serializing"},"Custom scalars that need custom parsing and serializing"),(0,r.kt)("p",null,"You define a custom scalar that needs a custom parser and serializer like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rescript"},"module Datetime: {\n  /** A date. */\n  @gql.scalar\n  type t\n\n  let parseValue: ResGraph.GraphQLLiteralValue.t => option<t>\n  let serialize: t => ResGraph.GraphQLLiteralValue.t\n} = {\n  type t = Date.t\n\n  open ResGraph.GraphQLLiteralValue\n\n  let parseValue = v =>\n    switch v {\n    | String(str) => Some(Date.fromString(str))\n    | Number(timestamp) => Some(Date.fromTime(timestamp))\n    | _ => None\n    }\n\n  let serialize = d => d->Date.toJSON->Option.getExn->String\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA date.\n"""\nscalar Datetime\n')),(0,r.kt)("p",null,"Let's distill what's going on here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Datetime.t")," is opaque, and the underlying type is ",(0,r.kt)("inlineCode",{parentName:"li"},"Date.t"),", which isn't a ",(0,r.kt)("a",{parentName:"li",href:"valid-graphql-types"},"valid GraphQL type"),"."),(0,r.kt)("li",{parentName:"ul"},"We define ",(0,r.kt)("inlineCode",{parentName:"li"},"parseValue: ResGraph.GraphQLLiteralValue.t => option<t>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"serialize: t => ResGraph.GraphQLLiteralValue.t"),". These need to be defined ",(0,r.kt)("em",{parentName:"li"},"exactly")," like this, as in be called those names, and use ",(0,r.kt)("inlineCode",{parentName:"li"},"GraphQLLiteralValue.t")," + the local ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," type."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parseValue")," is responsible for parsing the value GraphQL gives you at runtime, into your local ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"serialize")," is responsible for turning your ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," into a literal value that can be transferred to the client.")),(0,r.kt)("p",null,"With this, your custom scalar can now be serialized and parsed even if it isn't backed by a valid GraphQL type."))}m.isMDXComponent=!0}}]);