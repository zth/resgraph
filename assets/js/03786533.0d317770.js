"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[695],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),c=l(t),h=o,g=c["".concat(s,".").concat(h)]||c[h]||d[h]||a;return t?r.createElement(g,i(i({ref:n},p),{},{components:t})):r.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=h;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u[c]="string"==typeof e?e:o,i[1]=u;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1188:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>u,toc:()=>l});var r=t(7462),o=(t(7294),t(3905));const a={sidebar_position:8},i="Input Unions",u={unversionedId:"input-unions",id:"input-unions",title:"Input Unions",description:"Even though they're not officially in the spec yet, ResGraph has first class support for input unions via the @oneOf server directive proposal.",source:"@site/docs/input-unions.md",sourceDirName:".",slug:"/input-unions",permalink:"/resgraph/docs/input-unions",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/input-unions.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Query",permalink:"/resgraph/docs/query"},next:{title:"Mutations",permalink:"/resgraph/docs/mutation"}},s={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Using Input Unions",id:"using-input-unions",level:2},{value:"Comments",id:"comments",level:3},{value:"Handling <code>null</code>",id:"handling-null",level:3},{value:"Recursive input unions",id:"recursive-input-unions",level:3}],p={toc:l},c="wrapper";function d(e){let{components:n,...t}=e;return(0,o.kt)(c,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"input-unions"},"Input Unions"),(0,o.kt)("p",null,"Even though they're not officially in the spec yet, ResGraph has first class support for ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-spec/pull/825"},"input unions via the ",(0,o.kt)("inlineCode",{parentName:"a"},"@oneOf")," server directive proposal"),"."),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"You'll need to add the ",(0,o.kt)("inlineCode",{parentName:"p"},"@oneOf")," validation package and configure it in your server to be able to use input unions. It looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"# First, install the package that has the validation rule. This is using graphql-yoga@3.\nnpm i @envelop/extended-validation@2\n")),(0,o.kt)("p",null,"Next, add the plugin to your GraphQL Yoga server:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rescript"},"open GraphQLYoga\n\nlet yoga = createYoga({\n  schema: ResGraphSchema.schema,\n  plugins: [\n    Envelope.Plugin.ExtendedValidation.use({\n      rules: [Envelope.Plugin.ExtendedValidation.Rule.oneOfInputObjectsRule],\n    }),\n  ],\n")),(0,o.kt)("p",null,"Now you should be all set!"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can ",(0,o.kt)("a",{parentName:"p",href:"https://the-guild.dev/graphql/envelop/docs/guides/using-graphql-features-from-the-future"},"read more here")," on how this plugin works with GraphQL Yoga.")),(0,o.kt)("h2",{id:"using-input-unions"},"Using Input Unions"),(0,o.kt)("p",null,"Input unions are unions that can be used as inputs for fields and mutations. Input unions are regular variants in ResGraph, where the payload can be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Any valid GraphQL type that can be used in an input position"),(0,o.kt)("li",{parentName:"ul"},"An inline record")),(0,o.kt)("p",null,"Using an inline record will produce a new input object type for only this inline record."),(0,o.kt)("p",null,"Input unions are defined by using a variant annotated with ",(0,o.kt)("inlineCode",{parentName:"p"},"@gql.inputUnion"),". Full example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rescript"},"/** Searching for a user by group. */\n@gql.inputObject\ntype userSearchByGroupConfig = {\n  groupId: ResGraph.id,\n  userMemberToken?: string,\n}\n\n/** Config for searching for a user. */\n@gql.inputUnion\ntype userSearchConfig = ByGroup(userSearchByGroupConfig) | ByName(string) | ByUserToken({userToken: ResGraph.id})\n\n@gql.field\nlet searchForUser = (_: query, ~input: userSearchConfig, ~ctx: ResGraphContext.context): option<user> => {\n  switch input {\n  | ByGroup({groupId, userMemberToken}) => ctx.dataLoaders.searchForUserByGroup.load(~userMemberToken, ~groupId)\n  | ByName({groupId, userMemberToken}) => ctx.dataLoaders.searchForUserByName.load(name)\n  | ByUserToken({userToken}) => ctx.dataLoaders.searchForUserByToken.load(userToken)\n  }\n\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nSearching for a user by group.\n"""\ninput UserSearchByGroupConfig {\n  groupId: ID!\n  userMemberToken: String\n}\n\ninput UserSearchConfigByUserToken {\n  userToken: ID!\n}\n\n"""\nConfig for searching for a user.\n"""\ninput UserSearchConfig @oneOf {\n  byGroup: UserSearchByGroupConfig\n  byName: String\n  byUserToken: UserSearchConfigByUserToken\n}\n\ntype Query {\n  searchForUser(input: UserSearchConfig!): User\n}\n')),(0,o.kt)("p",null,"As with regular input objects, all fields are automatically exposed."),(0,o.kt)("h3",{id:"comments"},"Comments"),(0,o.kt)("p",null,"You can add comments to the type definition itself, and to all record fields. These will then be exposed in your schema."),(0,o.kt)("h3",{id:"handling-null"},"Handling ",(0,o.kt)("inlineCode",{parentName:"h3"},"null")),(0,o.kt)("p",null,"Just like in ",(0,o.kt)("a",{parentName:"p",href:"object-types#handling-null-in-arguments"},"arguments of object type fields"),", you can choose to explicitly handle ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," values by annotating any field or member in the input union to be ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),"."),(0,o.kt)("h3",{id:"recursive-input-unions"},"Recursive input unions"),(0,o.kt)("p",null,"As with input objects, input unions are allowed to be (mutually) recursive, if they're not recursive in a non-nullable way, as that would create an endless loop."),(0,o.kt)("p",null,"Read more ",(0,o.kt)("a",{parentName:"p",href:"input-objects"},"in the input object docs"),"."))}d.isMDXComponent=!0}}]);