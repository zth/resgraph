"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[780],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),f=o,m=p["".concat(s,".").concat(f)]||p[f]||d[f]||a;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},2337:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={sidebar_position:7},i="Input Objects",l={unversionedId:"input-objects",id:"input-objects",title:"Input Objects",description:"Input objects are defined by using a record annotated with @gql.inputObject:",source:"@site/docs/input-objects.md",sourceDirName:".",slug:"/input-objects",permalink:"/resgraph/docs/input-objects",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/input-objects.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Custom Scalars",permalink:"/resgraph/docs/custom-scalars"},next:{title:"Query",permalink:"/resgraph/docs/query"}},s={},c=[{value:"Comments",id:"comments",level:3},{value:"Handling <code>null</code>",id:"handling-null",level:3},{value:"Recursive input objects",id:"recursive-input-objects",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"input-objects"},"Input Objects"),(0,o.kt)("p",null,"Input objects are defined by using a record annotated with ",(0,o.kt)("inlineCode",{parentName:"p"},"@gql.inputObject"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rescript"},"/** Config for searching for a user. */\n@gql.inputObject\ntype userSearchConfig = {\n  groupId?: ResGraph.id,\n  name?: string,\n}\n\n@gql.field\nlet searchForUser = (_: query, ~input: userConfig, ~ctx: ResGraphContext.context): option<user> => {\n  ctx.dataLoaders.searchForUser.load(~name=input.name, ~groupId=input.groupId)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"input UserSearchConfig {\n  groupId: ID\n  name: String\n}\n\ntype Query {\n  searchForUser(input: UserSearchConfig!): User\n}\n")),(0,o.kt)("p",null,"One big difference compared to ",(0,o.kt)("a",{parentName:"p",href:"object-types#fields"},"object type fields")," is that in input objects, all fields are automatically exposed, because the contrary wouldn't make sense since this is an input from the client and not something you're supposed to construct yourself."),(0,o.kt)("h3",{id:"comments"},"Comments"),(0,o.kt)("p",null,"You can add comments to the type definition itself, and to all record fields. These will then be exposed in your schema."),(0,o.kt)("h3",{id:"handling-null"},"Handling ",(0,o.kt)("inlineCode",{parentName:"h3"},"null")),(0,o.kt)("p",null,"Just like in ",(0,o.kt)("a",{parentName:"p",href:"object-types#handling-null-in-arguments"},"arguments of object type fields"),", you can choose to explicitly handle ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," values by annotating fields in the input object to be ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),"."),(0,o.kt)("h3",{id:"recursive-input-objects"},"Recursive input objects"),(0,o.kt)("p",null,"Input objects are allowed to be (mutually) recursive, if they're not recursive in a non-nullable way, as that would create an endless loop."),(0,o.kt)("p",null,"In ReScript, you'd handle that scenario like you'd normally handle mutually recursive types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rescript"},"/** Some user config. */\n@gql.inputObject\ntype rec userConfig = {\n  name?: string,\n  additionalConfig?: userConfig,\n  lastGroupConfig?: groupConfig,\n}\n@gql.inputObject /** Some group config. */\nand groupConfig = {\n  groupName: string,\n  additionalUserConfig?: userConfig,\n}\n")))}d.isMDXComponent=!0}}]);