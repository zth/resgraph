"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[780],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=l(n),m=a,f=c["".concat(u,".").concat(m)]||c[m]||d[m]||o;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2337:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:7},i="Input Objects",s={unversionedId:"input-objects",id:"input-objects",title:"Input Objects",description:"Input objects are defined by using a record annotated with @gql.inputObject:",source:"@site/docs/input-objects.md",sourceDirName:".",slug:"/input-objects",permalink:"/resgraph/docs/input-objects",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/input-objects.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Custom Scalars",permalink:"/resgraph/docs/custom-scalars"},next:{title:"Query",permalink:"/resgraph/docs/query"}},u={},l=[{value:"Comments",id:"comments",level:3},{value:"Handling <code>null</code>",id:"handling-null",level:3},{value:"Recursive input objects",id:"recursive-input-objects",level:3},{value:"Inferred input objects",id:"inferred-input-objects",level:3},{value:"When to use and not to use inferred input objects",id:"when-to-use-and-not-to-use-inferred-input-objects",level:4},{value:"Input unions",id:"input-unions",level:3}],p={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"input-objects"},"Input Objects"),(0,a.kt)("p",null,"Input objects are defined by using a record annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@gql.inputObject"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"/** Config for searching for a user. */\n@gql.inputObject\ntype userSearchConfig = {\n  groupId?: ResGraph.id,\n  name?: string,\n}\n\n@gql.field\nlet searchForUser = (_: query, ~input: userConfig, ~ctx: ResGraphContext.context): option<user> => {\n  ctx.dataLoaders.searchForUser.load(~name=input.name, ~groupId=input.groupId)\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"input UserSearchConfig {\n  groupId: ID\n  name: String\n}\n\ntype Query {\n  searchForUser(input: UserSearchConfig!): User\n}\n")),(0,a.kt)("p",null,"One big difference compared to ",(0,a.kt)("a",{parentName:"p",href:"object-types#fields"},"object type fields")," is that in input objects, all fields are automatically exposed, because the contrary wouldn't make sense since this is an input from the client and not something you're supposed to construct yourself."),(0,a.kt)("h3",{id:"comments"},"Comments"),(0,a.kt)("p",null,"You can add comments to the type definition itself, and to all record fields. These will then be exposed in your schema."),(0,a.kt)("h3",{id:"handling-null"},"Handling ",(0,a.kt)("inlineCode",{parentName:"h3"},"null")),(0,a.kt)("p",null,"Just like in ",(0,a.kt)("a",{parentName:"p",href:"object-types#handling-null-in-arguments"},"arguments of object type fields"),", you can choose to explicitly handle ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," values by annotating fields in the input object to be ",(0,a.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),"."),(0,a.kt)("h3",{id:"recursive-input-objects"},"Recursive input objects"),(0,a.kt)("p",null,"Input objects are allowed to be (mutually) recursive, if they're not recursive in a non-nullable way, as that would create an endless loop."),(0,a.kt)("p",null,"In ReScript, you'd handle that scenario like you'd normally handle mutually recursive types:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"/** Some user config. */\n@gql.inputObject\ntype rec userConfig = {\n  name?: string,\n  additionalConfig?: userConfig,\n  lastGroupConfig?: groupConfig,\n}\n@gql.inputObject /** Some group config. */\nand groupConfig = {\n  groupName: string,\n  additionalUserConfig?: userConfig,\n}\n")),(0,a.kt)("h3",{id:"inferred-input-objects"},"Inferred input objects"),(0,a.kt)("p",null,"ResGraph can infer input objects if you use a ",(0,a.kt)("a",{parentName:"p",href:"https://rescript-lang.org/docs/manual/latest/object"},"ReScript object")," as an argument. Remember that ReScript objects can be fully inferred from usage. This creates a great way to create an input object fully inferred from usage. Let's look at an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},'let userUpdateName = (_: mutation, ~input, ~ctx: ResGraphContext.context) => {\n  switch await ctx.db.user.updateStatus(\n    ~userId=input["userId"]->ResGraph.idToString,\n    ~newName=input["newName"],\n  ) {\n  | Ok(updatedUser) => Some(updatedUser)\n  | Error(_) => None\n  }\n}\n\n')),(0,a.kt)("p",null,"This would produce this schema:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"input UserUpdateNameInput {\n  userId: ID!\n  newName: String!\n}\n\ntype Mutation {\n  userUpdateName(input: UserUpdateNameInput!): User\n}\n")),(0,a.kt)("p",null,"Notice everything is inferred from usage, because ReScript infers ",(0,a.kt)("inlineCode",{parentName:"p"},"input")," as an object. And ResGraph leverages that to create an input object. Inferred input objects are named ",(0,a.kt)("inlineCode",{parentName:"p"},"<parentTypeName><fieldName><argumentName>"),", and can only appear in the argument position of a resolver."),(0,a.kt)("h4",{id:"when-to-use-and-not-to-use-inferred-input-objects"},"When to use and not to use inferred input objects"),(0,a.kt)("p",null,"Inferred input objects can be great for moving quickly, but they have the following downsides:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Can't use doc strings"),(0,a.kt)("li",{parentName:"ul"},"Can't be reused"),(0,a.kt)("li",{parentName:"ul"},"Can't be pattern matched like a record can")),(0,a.kt)("p",null,"So, prefer regular declared ",(0,a.kt)("inlineCode",{parentName:"p"},"@gql.inputObject"),", and use inferred input objects when you're protoyping or otherwise want to move as quickly as possible, or when you're doing something that's truly ad hoc and doesn't require documentation."),(0,a.kt)("h3",{id:"input-unions"},"Input unions"),(0,a.kt)("p",null,"Often you'll find yourself in a scenario where you want to your input to be ",(0,a.kt)("em",{parentName:"p"},"one of")," several different values. For this, ResGraph has first class support for ",(0,a.kt)("a",{parentName:"p",href:"input-unions"},"input unions"),"."))}d.isMDXComponent=!0}}]);