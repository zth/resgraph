"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),h=a,g=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return t?o.createElement(g,i(i({ref:n},p),{},{components:t})):o.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},2618:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=t(7462),a=(t(7294),t(3905));const r={},i="Pagination",s={unversionedId:"pagination",id:"pagination",title:"Pagination",description:"You're encouraged to read up on connections in GraphQL prior to reading this section. Here's an article, and there's a link to the official GraphQL documentation on pagination which explains the rationale for using connections well.",source:"@site/docs/pagination.md",sourceDirName:".",slug:"/pagination",permalink:"/resgraph/docs/pagination",draft:!1,editUrl:"https://github.com/zth/resgraph/tree/main/docs/templates/shared/docs/pagination.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"The Node Interface",permalink:"/resgraph/docs/node-interface"},next:{title:"Relay",permalink:"/resgraph/docs/relay"}},l={},c=[{value:"Setting up a simple connection",id:"setting-up-a-simple-connection",level:2},{value:"Helpers for constructing connections",id:"helpers-for-constructing-connections",level:2},{value:"<code>connectionFromArray</code>",id:"connectionfromarray",level:3},{value:"Extending the connection",id:"extending-the-connection",level:2},{value:"Adding more data to the connection",id:"adding-more-data-to-the-connection",level:2},{value:"Rolling your own connection entirely",id:"rolling-your-own-connection-entirely",level:2}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pagination"},"Pagination"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"You're encouraged to read up on connections in GraphQL prior to reading this section. Here's ",(0,a.kt)("a",{parentName:"p",href:"https://dev.to/zth/connection-based-pagination-in-graphql-2588"},"an article"),", and there's a link to the ",(0,a.kt)("a",{parentName:"p",href:"https://graphql.org/learn/pagination"},"official GraphQL documentation on pagination")," which explains the rationale for using connections well.")),(0,a.kt)("p",null,"The best practice for doing pagination in GraphQL is leveraging a concept called connections. Connections are an integral part of building a GraphQL server following best practices. ResGraph comes with a number of conveniences to make working with connections simpler. Let's dive into what they are and how to use them."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Throughout this text, remember that while ResGraph ships with helpers for connections, ",(0,a.kt)("em",{parentName:"p"},"connections are nothing but a specification"),". You can create your own hand rolled connections by just defining types, you don't have to use what ResGraph ships. It's just there for convenience.")),(0,a.kt)("h2",{id:"setting-up-a-simple-connection"},"Setting up a simple connection"),(0,a.kt)("p",null,"ResGraph comes with pre-defined type creators (TODO: Link) for easily creating new connections:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.type\ntype user = {\n  id: string,\n  @gql.field name: string\n}\n\n/** An edge to a user. */\n@gql.type\ntype userEdge = ResGraph.Connections.edge<user>\n\n/** A connection to users. */\n@gql.type\ntype userConnection = ResGraph.Connections.connection<userEdge>\n")),(0,a.kt)("p",null,"There, we have the simplest possible connection set up, by using the built-in ",(0,a.kt)("inlineCode",{parentName:"p"},"ResGraph.Connections.edge<'node>")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ResGraph.Connections.node<'edge>"),". This will create a connection type and an edge type hooked up to that connection type. It generates this GraphQL:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA connection to users.\n"""\ntype UserConnection {\n  """\n  Information to aid in pagination.\n  """\n  pageInfo: PageInfo!\n\n  """\n  A list of edges.\n  """\n  edges: [UserEdge]\n}\n\n"""\nAn edge to a user.\n"""\ntype UserEdge {\n  """\n  The item at the end of the edge.\n  """\n  node: User\n\n  """\n  A cursor for use in pagination.\n  """\n  cursor: String!\n}\n')),(0,a.kt)("p",null,"You can then return this connection from a field just like you'd return any type."),(0,a.kt)("h2",{id:"helpers-for-constructing-connections"},"Helpers for constructing connections"),(0,a.kt)("p",null,"When doing real connection based pagination on the backend you'll naturally fill in the full connection yourself as you return it from fields."),(0,a.kt)("p",null,"But, it can be useful to present list data to the client as a connection even if what you have on the backend isn't a real connection. For this, ResGraph ships with a few helpers incorporated from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphql/graphql-relay-js"},(0,a.kt)("inlineCode",{parentName:"a"},"graphql-relay")),"."),(0,a.kt)("p",null,"Let's look at how we can leverage those helpers to return a connection even if all we have on the backend is a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"user")," and not a real connection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.type\ntype user = {\n  id: string,\n  @gql.field name: string,\n}\n\n/** An edge to a user. */\n@gql.type\ntype userEdge = ResGraph.Connections.edge<user>\n\n/** A connection to users. */\n@gql.type\ntype userConnection = ResGraph.Connections.connection<userEdge>\n\n/** All currently active users. */\n@gql.field\nlet currentlyActiveUsers = async (\n  _: query,\n  ~ctx: ResGraphContext.context,\n  ~first,\n  ~after,\n  ~before,\n  ~last,\n): userConnection => {\n  // Returns array<user>\n  let activeUsers = await ctx.dataLoaders.activeUsers.load()\n\n  activeUsers->ResGraph.Connections.connectionFromArray(\n    ~args={first, after, before, last},\n  )\n}\n")),(0,a.kt)("p",null,"And this will generate the following GraphQL:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA connection to users.\n"""\ntype UserConnection {\n  """\n  Information to aid in pagination.\n  """\n  pageInfo: User!\n\n  """\n  A list of edges.\n  """\n  edges: [UserEdge]\n}\n\n"""\nAn edge to a user.\n"""\ntype UserEdge {\n  """\n  The item at the end of the edge.\n  """\n  node: User\n\n  """\n  A cursor for use in pagination.\n  """\n  cursor: String!\n}\n\ntype Query {\n  """\n  All currently active users.\n  """\n  currentlyActiveUsers(\n    first: Int\n    after: String\n    before: String\n    last: Int\n  ): UserConnection!\n}\n')),(0,a.kt)("p",null,"Let's look a bit deeper into what we did, and how it works:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"First notice we're adding all connection arguments (",(0,a.kt)("inlineCode",{parentName:"li"},"first"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"last"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"before"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"after"),") to our field function. Also notice we're not annotating them with types - let inference do its thing! ",(0,a.kt)("inlineCode",{parentName:"li"},"args")," of ",(0,a.kt)("inlineCode",{parentName:"li"},"connectionFromArray")," knows what types they should be, so we let ReScript infer that for us."),(0,a.kt)("li",{parentName:"ol"},"Also notice that we're annotating the return type of the function with ",(0,a.kt)("inlineCode",{parentName:"li"},"userConnection"),". This is important when using the ",(0,a.kt)("inlineCode",{parentName:"li"},"connectionFromArray")," helper, because it returns a ",(0,a.kt)("em",{parentName:"li"},"generic")," connection, and ResGraph won't understand that that generic connection is in fact ",(0,a.kt)("inlineCode",{parentName:"li"},"userConnection")," unless we tell it."),(0,a.kt)("li",{parentName:"ol"},"We then call a fictive data loader that returns an array of ",(0,a.kt)("inlineCode",{parentName:"li"},"user"),". Notice it returns an array, and not a connection."),(0,a.kt)("li",{parentName:"ol"},"Finally, we use ",(0,a.kt)("inlineCode",{parentName:"li"},"connectionFromArray")," to turn our array of ",(0,a.kt)("inlineCode",{parentName:"li"},"user")," into a ",(0,a.kt)("inlineCode",{parentName:"li"},"connection<user>"),", which is the same as ",(0,a.kt)("inlineCode",{parentName:"li"},"userConnection"),".")),(0,a.kt)("p",null,"That last part may seem a bit magical, so we'll briefly dig into how ",(0,a.kt)("inlineCode",{parentName:"p"},"connectionFromArray")," works next."),(0,a.kt)("h3",{id:"connectionfromarray"},(0,a.kt)("inlineCode",{parentName:"h3"},"connectionFromArray")),(0,a.kt)("p",null,"This helper will create a ",(0,a.kt)("em",{parentName:"p"},"synthetic")," connection from an array of items. It does that by simply slicing the array according to the arguments you give it, and keep track of ",(0,a.kt)("em",{parentName:"p"},"where")," in the array it's currently at by using the item indexes of the array as cursors."),(0,a.kt)("p",null,"It's a simple and fast way of exposing array-based data as a connection to the frontend, so that the frontend can easily choose how much data to fetch, and paginate that data, even if the backend practically does not support pagination for that array of items."),(0,a.kt)("p",null,"For this to work, the array you leverage needs to be ",(0,a.kt)("em",{parentName:"p"},"static")," (as in it doesn't change frequently). This is important, because if the array changes, you'll end up getting the wrong items in the client as you paginate."),(0,a.kt)("p",null,"Use this helper with caution. It's typically a good idea to use when you want to expose a list of something as a connection, preferably where it's not intended to be paginated a lot. If you intend to also paginate that list a lot, make it a real connection on the backend instead."),(0,a.kt)("h2",{id:"extending-the-connection"},"Extending the connection"),(0,a.kt)("p",null,"Edges and connections are regular ",(0,a.kt)("a",{parentName:"p",href:"object-types"},"object types"),", so you can add fields to your connection (and your edges) by defining ",(0,a.kt)("a",{parentName:"p",href:"object-types#adding-fields-to-types-via-functions"},"field functions via ",(0,a.kt)("inlineCode",{parentName:"a"},"@gql.field")),", just like with any other object type."),(0,a.kt)("p",null,"If you find yourself wanting to change the documentation for a field in the generated connection, you can easily do so with a field function as well, that just returns the underlying data directly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"/** The user for this edge. */\n@gql.field\nlet node = (edge: userEdge) => {\n  edge.node\n}\n")),(0,a.kt)("p",null,"Generates:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nAn edge to a user.\n"""\ntype UserEdge {\n  """\n  The user for this edge.\n  """\n  node: User\n\n  """\n  A cursor for use in pagination.\n  """\n  cursor: String!\n}\n')),(0,a.kt)("h2",{id:"adding-more-data-to-the-connection"},"Adding more data to the connection"),(0,a.kt)("p",null,"Sometimes you'll want to expose fields on the connection that requires more data than what the generic connection shape allows for. For those instances, there's a sibling to ",(0,a.kt)("inlineCode",{parentName:"p"},"ResGraph.Connections.connection<'edge>")," called ",(0,a.kt)("inlineCode",{parentName:"p"},"ResGraph.Connections.connectionWithExtra<'edge, 'extra>"),". Using that connection type creator allows you to add data you can access in the connection via a field ",(0,a.kt)("inlineCode",{parentName:"p"},"extra: 'extra"),". Let's look at an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.type\ntype userEdge = ResGraph.Connections.edge<user>\n\ntype connectionExtra = {totalCountFromServer: int}\n\n@gql.type\ntype userConnection = ResGraph.Connections.connectionWithExtra<userEdge, connectionExtra>\n")),(0,a.kt)("p",null,"Here we define our ",(0,a.kt)("inlineCode",{parentName:"p"},"userConnection")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"connectionWithExtra"),", which allows us to attach extra data to the connection."),(0,a.kt)("p",null,"With this, we can expose a field returning ",(0,a.kt)("inlineCode",{parentName:"p"},"totalCountFromServer")," easily:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"/** The total amount of data available on the server. */\n@gql.field\nlet totalCount = (connection: userConnection) => {\n  Some(connection.extra.totalCountFromServer)\n}\n")),(0,a.kt)("p",null,"Finally, whenever constructing this connection we'll use ",(0,a.kt)("inlineCode",{parentName:"p"},"connectionFromArrayWithExtra")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"connectionFromArray")," to create our connection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"/** All currently active users. */\n@gql.field\nlet currentlyActiveUsers = async (\n  _: query,\n  ~ctx: ResGraphContext.context,\n  ~first,\n  ~after,\n  ~before,\n  ~last,\n): userConnection => {\n  // Returns {activeUsers: array<user>, totalCount: int}\n  let {activeUsers, totalCount} = await ctx.dataLoaders.activeUsers.load()\n\n  activeUsers->ResGraph.Connections.connectionFromArrayWithExtra(\n    ~args={first, after, before, last},\n    ~extra={totalCountFromServer: totalCount}\n  )\n}\n")),(0,a.kt)("p",null,"There, we've now added another field to our (generic) connection, that's backed by extra data added to the connection. This results in the following GraphQL:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'"""\nA connection to users.\n"""\ntype UserConnection {\n  """\n  The total amount of data available on the server.\n  """\n  totalCount: Int\n\n  """\n  Information to aid in pagination.\n  """\n  pageInfo: PageInfo!\n\n  """\n  A list of edges.\n  """\n  edges: [UserEdge]\n}\n\n"""\nAn edge to a user.\n"""\ntype UserEdge {\n  """\n  The item at the end of the edge.\n  """\n  node: User\n\n  """\n  A cursor for use in pagination.\n  """\n  cursor: String!\n}\n\ntype Query {\n  """\n  All currently active users.\n  """\n  currentlyActiveUsers(\n    first: Int\n    after: String\n    before: String\n    last: Int\n  ): UserConnection!\n}\n')),(0,a.kt)("h2",{id:"rolling-your-own-connection-entirely"},"Rolling your own connection entirely"),(0,a.kt)("p",null,"The helpers presented above are intended to solve the ",(0,a.kt)("em",{parentName:"p"},"basic")," cases. If you have more advanced cases, like adding fields that can't be derived from the basic data to the edges of a connection, you're encouraged to just roll your own connection definition and construct the connection data by hand, leveraging the connection arguments ",(0,a.kt)("inlineCode",{parentName:"p"},"first"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"last"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"before"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"after")," provided to you, and so on."),(0,a.kt)("p",null,"It's as easy as defining your own ",(0,a.kt)("inlineCode",{parentName:"p"},"@gql.type")," for the edge and connection. Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"@gql.type\n/** An edge in a connection. */\ntype userEdge = {\n  /** A cursor for use in pagination. */\n  @gql.field\n  cursor: string,\n  /** The item at the end of the edge. */\n  @gql.field\n  node: option<user>\n}\n\n/** A connection to a list of items. */\n@gql.type\ntype userConnection = {\n  /** Information to aid in pagination. */\n  @gql.field\n  pageInfo: ResGraph.Connections.pageInfo,\n  /** A list of edges. */\n  @gql.field\n  edges: option<array<option<userEdge>>>\n}\n")),(0,a.kt)("p",null,"You'll need to implement the logic for constructing and paginating the connection yourself, but you can leverage inference and the ",(0,a.kt)("inlineCode",{parentName:"p"},"ResGraph.Connections.connectionArgs")," type to help you take the correct connection arguments for your field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rescript"},"/** Friends of the user. */\n@gql.field\nlet friends = async (\n  user: user,\n  ~ctx: ResGraphContext.context,\n  ~first,\n  ~after,\n  ~last,\n  ~before,\n) => {\n  // Fictive loader that returns a complete `userConnection`.\n  // (~userId: string, ~args: ResGraph.Connections.connectionArgs) => promise<userConnection>\n  let userFriends = await ctx.dataLoaders.user.friends.load(\n    ~userId=user.id,\n    ~args={\n      first,\n      after,\n      last,\n      before,\n    },\n  )\n\n  Some(userFriends)\n}\n")),(0,a.kt)("p",null,"Here our data loader takes ",(0,a.kt)("inlineCode",{parentName:"p"},"ResGraph.Connections.connectionArgs"),", which again let us not have to worry about the types of the args ",(0,a.kt)("inlineCode",{parentName:"p"},"first"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"after"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"before"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"last"),", thanks to inference."))}u.isMDXComponent=!0}}]);